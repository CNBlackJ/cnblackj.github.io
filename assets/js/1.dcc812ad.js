(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{55:function(i,n,a){"use strict";a.r(n);var l=a(0),t=Object(l.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var i=this,n=i.$createElement,a=i._self._c||n;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"arduino驱动64-48的oled屏幕"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arduino驱动64-48的oled屏幕","aria-hidden":"true"}},[i._v("#")]),i._v(" arduino驱动64*48的OLED屏幕")]),a("h2",{attrs:{id:"材料准备"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#材料准备","aria-hidden":"true"}},[i._v("#")]),i._v(" 材料准备")]),a("ul",[a("li",[i._v("Arduino Uno")]),a("li",[i._v("OLED屏幕")])]),a("h2",{attrs:{id:"接线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接线","aria-hidden":"true"}},[i._v("#")]),i._v(" 接线")]),a("table",[a("thead",[a("tr",[a("th",[i._v("OLED")]),a("th",[i._v("Arduino")])])]),a("tbody",[a("tr",[a("td",[i._v("GND")]),a("td",[i._v("GND")])]),a("tr",[a("td",[i._v("VCC")]),a("td",[i._v("5v")])]),a("tr",[a("td",[i._v("SCL")]),a("td",[i._v("A4")])]),a("tr",[a("td",[i._v("SDA")]),a("td",[i._v("A5")])])])]),a("h2",{attrs:{id:"程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#程序","aria-hidden":"true"}},[i._v("#")]),i._v(" 程序")]),a("h3",{attrs:{id:"驱动库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#驱动库","aria-hidden":"true"}},[i._v("#")]),i._v(" 驱动库")]),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/adafruit/Adafruit_SSD1306",target:"_blank",rel:"noopener noreferrer"}},[i._v("Adafruit_SSD1306")])])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[i._v('// 示例代码：ssd1306_128x64_i2c\n#include <SPI.h>\n#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n#define OLED_RESET 4\nAdafruit_SSD1306 display(OLED_RESET);\n\n#define NUMFLAKES 10\n#define XPOS 0\n#define YPOS 1\n#define DELTAY 2\n\n\n#define LOGO16_GLCD_HEIGHT 16 \n#define LOGO16_GLCD_WIDTH  16 \nstatic const unsigned char PROGMEM logo16_glcd_bmp[] =\n{ B00000000, B11000000,\n  B00000001, B11000000,\n  B00000001, B11000000,\n  B00000011, B11100000,\n  B11110011, B11100000,\n  B11111110, B11111000,\n  B01111110, B11111111,\n  B00110011, B10011111,\n  B00011111, B11111100,\n  B00001101, B01110000,\n  B00011011, B10100000,\n  B00111111, B11100000,\n  B00111111, B11110000,\n  B01111100, B11110000,\n  B01110000, B01110000,\n  B00000000, B00110000 };\n\n#if (SSD1306_LCDHEIGHT != 64)\n#error("Height incorrect, please fix Adafruit_SSD1306.h!");\n#endif\n\nvoid setup()   {                \n  Serial.begin(9600);\n\n  // by default, we\'ll generate the high voltage from the 3.3v line internally! (neat!)\n  display.begin(SSD1306_SWITCHCAPVCC, 0x3D);  // initialize with the I2C addr 0x3D (for the 128x64)\n  // init done\n  \n  // Show image buffer on the display hardware.\n  // Since the buffer is intialized with an Adafruit splashscreen\n  // internally, this will display the splashscreen.\n  display.display();\n  delay(2000);\n\n  // Clear the buffer.\n  display.clearDisplay();\n\n  // draw a single pixel\n  display.drawPixel(10, 10, WHITE);\n  // Show the display buffer on the hardware.\n  // NOTE: You _must_ call display after making any drawing commands\n  // to make them visible on the display hardware!\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // draw many lines\n  testdrawline();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // draw rectangles\n  testdrawrect();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // draw multiple rectangles\n  testfillrect();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // draw mulitple circles\n  testdrawcircle();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // draw a white circle, 10 pixel radius\n  display.fillCircle(display.width()/2, display.height()/2, 10, WHITE);\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  testdrawroundrect();\n  delay(2000);\n  display.clearDisplay();\n\n  testfillroundrect();\n  delay(2000);\n  display.clearDisplay();\n\n  testdrawtriangle();\n  delay(2000);\n  display.clearDisplay();\n   \n  testfilltriangle();\n  delay(2000);\n  display.clearDisplay();\n\n  // draw the first ~12 characters in the font\n  testdrawchar();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // draw scrolling text\n  testscrolltext();\n  delay(2000);\n  display.clearDisplay();\n\n  // text display tests\n  display.setTextSize(1);\n  display.setTextColor(WHITE);\n  display.setCursor(0,0);\n  display.println("Hello, world!");\n  display.setTextColor(BLACK, WHITE); // \'inverted\' text\n  display.println(3.141592);\n  display.setTextSize(2);\n  display.setTextColor(WHITE);\n  display.print("0x"); display.println(0xDEADBEEF, HEX);\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // miniature bitmap display\n  display.drawBitmap(30, 16,  logo16_glcd_bmp, 16, 16, 1);\n  display.display();\n  delay(1);\n\n  // invert the display\n  display.invertDisplay(true);\n  delay(1000); \n  display.invertDisplay(false);\n  delay(1000); \n  display.clearDisplay();\n\n  // draw a bitmap icon and \'animate\' movement\n  testdrawbitmap(logo16_glcd_bmp, LOGO16_GLCD_HEIGHT, LOGO16_GLCD_WIDTH);\n}\n\n\nvoid loop() {\n  \n}\n\n\nvoid testdrawbitmap(const uint8_t *bitmap, uint8_t w, uint8_t h) {\n  uint8_t icons[NUMFLAKES][3];\n \n  // initialize\n  for (uint8_t f=0; f< NUMFLAKES; f++) {\n    icons[f][XPOS] = random(display.width());\n    icons[f][YPOS] = 0;\n    icons[f][DELTAY] = random(5) + 1;\n    \n    Serial.print("x: ");\n    Serial.print(icons[f][XPOS], DEC);\n    Serial.print(" y: ");\n    Serial.print(icons[f][YPOS], DEC);\n    Serial.print(" dy: ");\n    Serial.println(icons[f][DELTAY], DEC);\n  }\n\n  while (1) {\n    // draw each icon\n    for (uint8_t f=0; f< NUMFLAKES; f++) {\n      display.drawBitmap(icons[f][XPOS], icons[f][YPOS], bitmap, w, h, WHITE);\n    }\n    display.display();\n    delay(200);\n    \n    // then erase it + move it\n    for (uint8_t f=0; f< NUMFLAKES; f++) {\n      display.drawBitmap(icons[f][XPOS], icons[f][YPOS], bitmap, w, h, BLACK);\n      // move it\n      icons[f][YPOS] += icons[f][DELTAY];\n      // if its gone, reinit\n      if (icons[f][YPOS] > display.height()) {\n        icons[f][XPOS] = random(display.width());\n        icons[f][YPOS] = 0;\n        icons[f][DELTAY] = random(5) + 1;\n      }\n    }\n   }\n}\n\n\nvoid testdrawchar(void) {\n  display.setTextSize(1);\n  display.setTextColor(WHITE);\n  display.setCursor(0,0);\n\n  for (uint8_t i=0; i < 168; i++) {\n    if (i == \'\\n\') continue;\n    display.write(i);\n    if ((i > 0) && (i % 21 == 0))\n      display.println();\n  }    \n  display.display();\n  delay(1);\n}\n\nvoid testdrawcircle(void) {\n  for (int16_t i=0; i<display.height(); i+=2) {\n    display.drawCircle(display.width()/2, display.height()/2, i, WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testfillrect(void) {\n  uint8_t color = 1;\n  for (int16_t i=0; i<display.height()/2; i+=3) {\n    // alternate colors\n    display.fillRect(i, i, display.width()-i*2, display.height()-i*2, color%2);\n    display.display();\n    delay(1);\n    color++;\n  }\n}\n\nvoid testdrawtriangle(void) {\n  for (int16_t i=0; i<min(display.width(),display.height())/2; i+=5) {\n    display.drawTriangle(display.width()/2, display.height()/2-i,\n                     display.width()/2-i, display.height()/2+i,\n                     display.width()/2+i, display.height()/2+i, WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testfilltriangle(void) {\n  uint8_t color = WHITE;\n  for (int16_t i=min(display.width(),display.height())/2; i>0; i-=5) {\n    display.fillTriangle(display.width()/2, display.height()/2-i,\n                     display.width()/2-i, display.height()/2+i,\n                     display.width()/2+i, display.height()/2+i, WHITE);\n    if (color == WHITE) color = BLACK;\n    else color = WHITE;\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testdrawroundrect(void) {\n  for (int16_t i=0; i<display.height()/2-2; i+=2) {\n    display.drawRoundRect(i, i, display.width()-2*i, display.height()-2*i, display.height()/4, WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testfillroundrect(void) {\n  uint8_t color = WHITE;\n  for (int16_t i=0; i<display.height()/2-2; i+=2) {\n    display.fillRoundRect(i, i, display.width()-2*i, display.height()-2*i, display.height()/4, color);\n    if (color == WHITE) color = BLACK;\n    else color = WHITE;\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testdrawrect(void) {\n  for (int16_t i=0; i<display.height()/2; i+=2) {\n    display.drawRect(i, i, display.width()-2*i, display.height()-2*i, WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testdrawline() {  \n  for (int16_t i=0; i<display.width(); i+=4) {\n    display.drawLine(0, 0, i, display.height()-1, WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i=0; i<display.height(); i+=4) {\n    display.drawLine(0, 0, display.width()-1, i, WHITE);\n    display.display();\n    delay(1);\n  }\n  delay(250);\n  \n  display.clearDisplay();\n  for (int16_t i=0; i<display.width(); i+=4) {\n    display.drawLine(0, display.height()-1, i, 0, WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i=display.height()-1; i>=0; i-=4) {\n    display.drawLine(0, display.height()-1, display.width()-1, i, WHITE);\n    display.display();\n    delay(1);\n  }\n  delay(250);\n  \n  display.clearDisplay();\n  for (int16_t i=display.width()-1; i>=0; i-=4) {\n    display.drawLine(display.width()-1, display.height()-1, i, 0, WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i=display.height()-1; i>=0; i-=4) {\n    display.drawLine(display.width()-1, display.height()-1, 0, i, WHITE);\n    display.display();\n    delay(1);\n  }\n  delay(250);\n\n  display.clearDisplay();\n  for (int16_t i=0; i<display.height(); i+=4) {\n    display.drawLine(display.width()-1, 0, 0, i, WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i=0; i<display.width(); i+=4) {\n    display.drawLine(display.width()-1, 0, i, display.height()-1, WHITE); \n    display.display();\n    delay(1);\n  }\n  delay(250);\n}\n\nvoid testscrolltext(void) {\n  display.setTextSize(2);\n  display.setTextColor(WHITE);\n  display.setCursor(10,0);\n  display.clearDisplay();\n  display.println("scroll");\n  display.display();\n  delay(1);\n\n  display.startscrollright(0x00, 0x0F);\n  delay(2000);\n  display.stopscroll();\n  delay(1000);\n  display.startscrollleft(0x00, 0x0F);\n  delay(2000);\n  display.stopscroll();\n  delay(1000);\n  display.startscrolldiagright(0x00, 0x07);\n  delay(2000);\n  display.startscrolldiagleft(0x00, 0x07);\n  delay(2000);\n  display.stopscroll();\n}\n')])]),a("h2",{attrs:{id:"注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意事项","aria-hidden":"true"}},[i._v("#")]),i._v(" 注意事项")]),a("ul",[a("li",[i._v("上面提到的驱动库有这么一行：")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[i._v("...\ndisplay.begin(SSD1306_SWITCHCAPVCC, 0x3D);\n...\n")])]),a("p",[i._v("这行里面有个"),a("code",[i._v("0x3D")]),i._v("这个地址，如果不确定自己的是哪个地址的话可以用下面这个程序进行检测：")]),a("ul",[a("li",[i._v("参考：https://playground.arduino.cc/Main/I2cScanner")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[i._v('#include <Wire.h>\n\nvoid setup()\n{\n  Wire.begin();\n\n  Serial.begin(9600);\n  while (!Serial);             // Leonardo: wait for serial monitor\n  Serial.println("\\nI2C Scanner");\n}\n\nvoid loop()\n{\n  byte error, address;\n  int nDevices;\n\n  Serial.println("Scanning...");\n\n  nDevices = 0;\n  for(address = 1; address < 127; address++ )\n  {\n    // The i2c_scanner uses the return value of\n    // the Write.endTransmisstion to see if\n    // a device did acknowledge to the address.\n    Wire.beginTransmission(address);\n    error = Wire.endTransmission();\n\n    if (error == 0)\n    {\n      Serial.print("I2C device found at address 0x");\n      if (address<16)\n        Serial.print("0");\n      Serial.print(address,HEX);\n      Serial.println("  !");\n\n      nDevices++;\n    }\n    else if (error==4)\n    {\n      Serial.print("Unknown error at address 0x");\n      if (address<16)\n        Serial.print("0");\n      Serial.println(address,HEX);\n    }\n  }\n  if (nDevices == 0)\n    Serial.println("No I2C devices found\\n");\n  else\n    Serial.println("done\\n");\n\n  delay(5000);           // wait 5 seconds for next scan\n}\n')])]),a("p",[i._v("我的检测出来是"),a("code",[i._v("0x3C")]),i._v("，所以需要把上面提到的"),a("code",[i._v("0x3D")]),i._v("改成"),a("code",[i._v("0x3C")]),i._v("，再烧录进去就可以了。\n我用了两块OLED屏幕并联在一起，同样可以正常显示。")]),a("p",[i._v("显示的图片：")]),a("p",[a("img",{attrs:{src:"https://article-imgs-1255936829.cos.ap-guangzhou.myqcloud.com/1.png",alt:"1"}}),a("img",{attrs:{src:"https://article-imgs-1255936829.cos.ap-guangzhou.myqcloud.com/2.png",alt:"2"}}),a("img",{attrs:{src:"https://article-imgs-1255936829.cos.ap-guangzhou.myqcloud.com/3.png",alt:"3"}}),a("img",{attrs:{src:"https://article-imgs-1255936829.cos.ap-guangzhou.myqcloud.com/4.png",alt:"4"}}),a("img",{attrs:{src:"https://article-imgs-1255936829.cos.ap-guangzhou.myqcloud.com/5.png",alt:"5"}}),a("img",{attrs:{src:"https://article-imgs-1255936829.cos.ap-guangzhou.myqcloud.com/6.png",alt:"6"}}),a("img",{attrs:{src:"https://article-imgs-1255936829.cos.ap-guangzhou.myqcloud.com/7.png",alt:"7"}}),a("img",{attrs:{src:"https://article-imgs-1255936829.cos.ap-guangzhou.myqcloud.com/8.png",alt:"8"}}),a("img",{attrs:{src:"https://article-imgs-1255936829.cos.ap-guangzhou.myqcloud.com/9.png",alt:"9"}}),a("img",{attrs:{src:"https://article-imgs-1255936829.cos.ap-guangzhou.myqcloud.com/10.png",alt:"10"}}),a("img",{attrs:{src:"https://article-imgs-1255936829.cos.ap-guangzhou.myqcloud.com/11.png",alt:"11"}})])])}],!1,null,null,null);n.default=t.exports}}]);